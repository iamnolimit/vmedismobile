// File: Services/LoginService.swift - Final Clean Versionimport Foundationstruct LoginResponse: Codable {    let status: String    let message: String?    let data: UserData?}struct UserData: Codable {    let id: Int?    let username: String?    let password: String?    let token: String?    let gr_id: Int?    let app_id: String?    let status: Int?    let keterangan: String?    let logo: String?    let lvl: Int?    let domain: String?    let nama_lengkap: String?    let kl_id: Int?    let app_jenis: Int?    let dokid: Int?    let kl_nama: String?    let kl_logo: String?    let kl_lat: String?    let kl_lng: String?    let countdown: String?    let langganan: String?    let created_at: Int?    let wizard: Int?    let app_reg: String?}@MainActorclass LoginService: ObservableObject {    private let baseURL = "https://api3.vmedismart.com"        func login(username: String, password: String, domain: String) async throws -> LoginResponse {        // Format tanggal sesuai dengan format yang digunakan        let dateFormatter = DateFormatter()        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"        let currentDate = dateFormatter.string(from: Date())                // Buat URL        guard let url = URL(string: "\(baseURL)/sys/login") else {            throw LoginError.invalidURL        }                // Setup request        var request = URLRequest(url: url)        request.httpMethod = "POST"        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")                // Buat form data parameters        let parameters = [            "u": username,            "p": password,            "t": domain,            "device": "ios",            "ip": "",            "date": currentDate        ]                // Convert to form data string        var formDataString = ""        for (key, value) in parameters {            if !formDataString.isEmpty {                formDataString += "&"            }            if let encodedKey = key.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),               let encodedValue = value.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) {                formDataString += "\(encodedKey)=\(encodedValue)"            }        }                // Set request body        request.httpBody = formDataString.data(using: .utf8)                // Debug: Print request        print("Request URL: \(url)")        print("Request Method: POST")        print("Content-Type: application/x-www-form-urlencoded")        print("Form Data: \(formDataString)")                // Kirim request        do {            let (data, response) = try await URLSession.shared.data(for: request)                        // Check HTTP response            if let httpResponse = response as? HTTPURLResponse {                print("HTTP Status Code: \(httpResponse.statusCode)")                print("Response Headers: \(httpResponse.allHeaderFields)")            }                        // Debug: Print raw response            if let responseString = String(data: data, encoding: .utf8) {                print("Raw Response: \(responseString)")            }                        // Try to decode as generic JSON first            if let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []) {                print("JSON Structure: \(jsonObject)")            }                        // Decode response            do {                let loginResponse = try JSONDecoder().decode(LoginResponse.self, from: data)                return loginResponse            } catch {                print("Detailed Decoding Error: \(error)")                                // Create fallback response for decoding errors                if let responseString = String(data: data, encoding: .utf8) {                    if responseString.contains("error") || responseString.contains("fail") {                        let fallbackResponse = LoginResponse(                            status: "error",                            message: responseString,                            data: nil                        )                        return fallbackResponse                    }                }                                throw LoginError.decodingError("Failed to decode response: \(error.localizedDescription)")            }                    } catch {            print("Network Error: \(error)")            throw LoginError.networkError(error)        }    }}enum LoginError: LocalizedError {    case invalidURL    case encodingError    case decodingError(String)    case networkError(Error)    case invalidCredentials    case serverError(String)        var errorDescription: String? {        switch self {        case .invalidURL:            return "Invalid URL"        case .encodingError:            return "Failed to encode request"        case .decodingError(let message):            return "Failed to decode response: \(message)"        case .networkError(let error):            return "Network error: \(error.localizedDescription)"        case .invalidCredentials:            return "Invalid username or password"        case .serverError(let message):            return message        }    }}