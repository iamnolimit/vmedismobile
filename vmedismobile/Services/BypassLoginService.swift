// File: Services/BypassLoginService.swift
import Foundation

struct TokenRequest: Codable {
    let user: TokenUserData
    let identity: TokenIdentityData
    let accessToken: String
    let expiredToken: Int
}

struct TokenUserData: Codable {
    let user_id: String  // Changed from Int to String to match UserData.id
    let username: String
    let gr_id: Int?
    let app_id: String?
    let status: Int?
    let keterangan: String?
    let logo: String?
    let lvl: Int?
    let domain: String
    let nama_lengkap: String?
    let app_jenis: Int?
    let app_reg: String?
    let gr_akses: String?
}

struct TokenIdentityData: Codable {
    let kl_id: Int?
    let kl_logo: String?
    let kl_nama: String?
    let kl_alamat: String?
    let kl_tlp: String?
    let kl_no_reg: String?
    let apt_logo: String?
    let apt_alamat: String?
    let apt_nama: String?
    let apt_no_reg: String?
    let apt_tlp: String?
}

struct TokenResponse: Codable {
    let status: String
    let message: String?
    let data: String?
}

class BypassLoginService: ObservableObject {
    static let shared = BypassLoginService()
    
    private let baseUrlReact = "https://v3.vmedis.com/"
    
    private init() {}    
    func generateTokenUrl(userData: UserData, destinationUrl: String = "mobile") async throws -> URL {
        // Generate access token similar to PHP implementation
        let currentTimeMillis = Int64(Date().timeIntervalSince1970 * 1000)
        let userId = userData.id ?? "0"
        let accessToken = Data("\(userId)--SED--\(currentTimeMillis)".utf8).base64EncodedString()
        
        // First, try the API-based approach
        do {
            // Prepare token request data
            let tokenRequest = TokenRequest(
                user: TokenUserData(
                    user_id: userId,
                    username: userData.username ?? "",
                    gr_id: userData.gr_id,
                    app_id: userData.app_id,
                    status: userData.status,
                    keterangan: userData.keterangan,
                    logo: userData.logo,
                    lvl: userData.lvl,
                    domain: userData.domain ?? "",
                    nama_lengkap: userData.nama_lengkap,
                    app_jenis: userData.app_jenis,
                    app_reg: userData.app_reg,
                    gr_akses: nil // This might need to be stored separately or fetched
                ),
                identity: TokenIdentityData(
                    kl_id: userData.kl_id,
                    kl_logo: userData.kl_logo,
                    kl_nama: userData.kl_nama,
                    kl_alamat: nil, // These properties might need to be added to UserData model
                    kl_tlp: nil,
                    kl_no_reg: nil,
                    apt_logo: nil,
                    apt_alamat: nil,
                    apt_nama: nil,
                    apt_no_reg: nil,
                    apt_tlp: nil
                ),
                accessToken: accessToken,
                expiredToken: Int(Date().timeIntervalSince1970) + 3600 // 1 hour expiration
            )
            
            // Make API request to get token
            let token = try await requestToken(tokenRequest: tokenRequest)
            
            // Build final URL with token
            let domain = userData.domain ?? ""
            let finalUrl = "\(baseUrlReact)\(domain)/auth?token=\(token)&menu=\(destinationUrl)"
            
            guard let url = URL(string: finalUrl) else {
                throw URLError(.badURL)
            }
            
            print("Generated bypass URL: \(finalUrl)")
            return url
            
        } catch {
            print("API-based bypass failed, trying fallback approach: \(error)")
            
            // Fallback: Try direct authentication approach
            return try await generateFallbackUrl(userData: userData, destinationUrl: destinationUrl, accessToken: accessToken)
        }
    }
      private func generateFallbackUrl(userData: UserData, destinationUrl: String, accessToken: String) async throws -> URL {        // Fallback approach - try to construct URL with direct token
        let domain = userData.domain ?? ""
        let userId = userData.id ?? "0"
        
        // Try different URL patterns that might work
        let fallbackUrls = [
            "\(baseUrlReact)\(domain)/auth?token=\(accessToken)&menu=\(destinationUrl)",
            "\(baseUrlReact)\(domain)/\(destinationUrl)?token=\(accessToken)",
            "\(baseUrlReact)\(domain)/\(destinationUrl)?domain=\(domain)&token=\(accessToken)",
            "\(baseUrlReact)\(domain)/\(destinationUrl)?domain=\(domain)&user=\(userId)"
        ]
        
        for urlString in fallbackUrls {
            if let url = URL(string: urlString) {
                print("Trying fallback URL: \(urlString)")
                return url
            }
        }
        
        // Final fallback - original URL with dynamic domain
        let originalUrl = "\(baseUrlReact)\(domain)/\(destinationUrl)"
        guard let url = URL(string: originalUrl) else {
            throw URLError(.badURL)
        }
        
        print("Using original URL as final fallback: \(originalUrl)")
        return url
    }
      private func requestToken(tokenRequest: TokenRequest) async throws -> String {
        let url = URL(string: "\(baseUrlReact)api/auth/get-token")!
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        
        let jsonData = try JSONEncoder().encode(tokenRequest)
        request.httpBody = jsonData
        
        // Debug: Print request details
        print("=== BYPASS LOGIN REQUEST ===")
        print("URL: \(url)")
        print("Request body: \(String(data: jsonData, encoding: .utf8) ?? "nil")")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        // Debug: Print response details
        print("=== BYPASS LOGIN RESPONSE ===")
        if let httpResponse = response as? HTTPURLResponse {
            print("Status Code: \(httpResponse.statusCode)")
            print("Headers: \(httpResponse.allHeaderFields)")
        }
        print("Response Data: \(String(data: data, encoding: .utf8) ?? "nil")")
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            print("HTTP Error: Status code \((response as? HTTPURLResponse)?.statusCode ?? 0)")
            throw URLError(.badServerResponse)
        }
        
        // Try to decode as TokenResponse first, but handle different response formats
        do {
            let tokenResponse = try JSONDecoder().decode(TokenResponse.self, from: data)
            
            guard tokenResponse.status == "success",
                  let token = tokenResponse.data else {
                print("Token response error: status=\(tokenResponse.status), data=\(tokenResponse.data ?? "nil")")
                throw URLError(.userAuthenticationRequired)
            }
            
            return token
        } catch {
            print("Failed to decode as TokenResponse: \(error)")
            
            // Try to handle different response formats
            if let responseString = String(data: data, encoding: .utf8) {
                // If response is just a plain token string
                if !responseString.isEmpty && !responseString.contains("{") {
                    print("Using response as direct token: \(responseString)")
                    return responseString.trimmingCharacters(in: .whitespacesAndNewlines)
                }
                
                // Try to parse as generic JSON and extract token
                if let jsonObject = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                    if let token = jsonObject["data"] as? String {
                        print("Extracted token from generic JSON: \(token)")
                        return token
                    }
                    if let token = jsonObject["token"] as? String {
                        print("Extracted token from 'token' field: \(token)")
                        return token
                    }
                }
            }
            
            throw error
        }
    }
}
